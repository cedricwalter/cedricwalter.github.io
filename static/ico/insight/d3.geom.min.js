(function() {
    function c(a) {
        var b = 0,
            c = 0;
        for (;;) {
            if (a(b, c)) return [b, c];
            b === 0 ? (b = c + 1, c = 0) : (b -= 1, c += 1)
        }
    }

    function d(a, b, c, d) {
        var e, f, g, h, i, j, k;
        return e = d[a], f = e[0], g = e[1], e = d[b], h = e[0], i = e[1], e = d[c], j = e[0], k = e[1], (k - g) * (h - f) - (i - g) * (j - f) > 0
    }

    function e(a, b, c) {
        return (c[0] - b[0]) * (a[1] - b[1]) < (c[1] - b[1]) * (a[0] - b[0])
    }

    function f(a, b, c, d) {
        var e = a[0],
            f = b[0],
            g = c[0],
            h = d[0],
            i = a[1],
            j = b[1],
            k = c[1],
            l = d[1],
            m = e - g,
            n = f - e,
            o = h - g,
            p = i - k,
            q = j - i,
            r = l - k,
            s = (o * p - r * m) / (r * n - o * q);
        return [e + s * n, i + s * q]
    }

    function h(a, b) {
        var c = {
                list: a.map(function(a, b) {
                    return {
                        index: b,
                        x: a[0],
                        y: a[1]
                    }
                }).sort(function(a, b) {
                    return a.y < b.y ? -1 : a.y > b.y ? 1 : a.x < b.x ? -1 : a.x > b.x ? 1 : 0
                }),
                bottomSite: null
            },
            d = {
                list: [],
                leftEnd: null,
                rightEnd: null,
                init: function() {
                    d.leftEnd = d.createHalfEdge(null, "l"), d.rightEnd = d.createHalfEdge(null, "l"), d.leftEnd.r = d.rightEnd, d.rightEnd.l = d.leftEnd, d.list.unshift(d.leftEnd, d.rightEnd)
                },
                createHalfEdge: function(a, b) {
                    return {
                        edge: a,
                        side: b,
                        vertex: null,
                        l: null,
                        r: null
                    }
                },
                insert: function(a, b) {
                    b.l = a, b.r = a.r, a.r.l = b, a.r = b
                },
                leftBound: function(a) {
                    var b = d.leftEnd;
                    do b = b.r; while (b != d.rightEnd && e.rightOf(b, a));
                    return b = b.l, b
                },
                del: function(a) {
                    a.l.r = a.r, a.r.l = a.l, a.edge = null
                },
                right: function(a) {
                    return a.r
                },
                left: function(a) {
                    return a.l
                },
                leftRegion: function(a) {
                    return a.edge == null ? c.bottomSite : a.edge.region[a.side]
                },
                rightRegion: function(a) {
                    return a.edge == null ? c.bottomSite : a.edge.region[g[a.side]]
                }
            },
            e = {
                bisect: function(a, b) {
                    var c = {
                            region: {
                                l: a,
                                r: b
                            },
                            ep: {
                                l: null,
                                r: null
                            }
                        },
                        d = b.x - a.x,
                        e = b.y - a.y,
                        f = d > 0 ? d : -d,
                        g = e > 0 ? e : -e;
                    return c.c = a.x * d + a.y * e + (d * d + e * e) * .5, f > g ? (c.a = 1, c.b = e / d, c.c /= d) : (c.b = 1, c.a = d / e, c.c /= e), c
                },
                intersect: function(a, b) {
                    var c = a.edge,
                        d = b.edge;
                    if (!c || !d || c.region.r == d.region.r) return null;
                    var e = c.a * d.b - c.b * d.a;
                    if (Math.abs(e) < 1e-10) return null;
                    var f = (c.c * d.b - d.c * c.b) / e,
                        g = (d.c * c.a - c.c * d.a) / e,
                        h = c.region.r,
                        i = d.region.r,
                        j, k;
                    h.y < i.y || h.y == i.y && h.x < i.x ? (j = a, k = c) : (j = b, k = d);
                    var l = f >= k.region.r.x;
                    return l && j.side === "l" || !l && j.side === "r" ? null : {
                        x: f,
                        y: g
                    }
                },
                rightOf: function(a, b) {
                    var c = a.edge,
                        d = c.region.r,
                        e = b.x > d.x;
                    if (e && a.side === "l") return 1;
                    if (!e && a.side === "r") return 0;
                    if (c.a === 1) {
                        var f = b.y - d.y,
                            g = b.x - d.x,
                            h = 0,
                            i = 0;
                        !e && c.b < 0 || e && c.b >= 0 ? i = h = f >= c.b * g : (i = b.x + b.y * c.b > c.c, c.b < 0 && (i = !i), i || (h = 1));
                        if (!h) {
                            var j = d.x - c.region.l.x;
                            i = c.b * (g * g - f * f) < j * f * (1 + 2 * g / j + c.b * c.b), c.b < 0 && (i = !i)
                        }
                    } else {
                        var k = c.c - c.a * b.x,
                            l = b.y - k,
                            m = b.x - d.x,
                            n = k - d.y;
                        i = l * l > m * m + n * n
                    }
                    return a.side === "l" ? i : !i
                },
                endPoint: function(a, c, d) {
                    a.ep[c] = d;
                    if (!a.ep[g[c]]) return;
                    b(a)
                },
                distance: function(a, b) {
                    var c = a.x - b.x,
                        d = a.y - b.y;
                    return Math.sqrt(c * c + d * d)
                }
            },
            f = {
                list: [],
                insert: function(a, b, c) {
                    a.vertex = b, a.ystar = b.y + c;
                    for (var d = 0, e = f.list, g = e.length; d < g; d++) {
                        var h = e[d];
                        if (a.ystar > h.ystar || a.ystar == h.ystar && b.x > h.vertex.x) continue;
                        break
                    }
                    e.splice(d, 0, a)
                },
                del: function(a) {
                    for (var b = 0, c = f.list, d = c.length; b < d && c[b] != a; ++b);
                    c.splice(b, 1)
                },
                empty: function() {
                    return f.list.length === 0
                },
                nextEvent: function(a) {
                    for (var b = 0, c = f.list, d = c.length; b < d; ++b)
                        if (c[b] == a) return c[b + 1];
                    return null
                },
                min: function() {
                    var a = f.list[0];
                    return {
                        x: a.vertex.x,
                        y: a.ystar
                    }
                },
                extractMin: function() {
                    return f.list.shift()
                }
            };
        d.init(), c.bottomSite = c.list.shift();
        var h = c.list.shift(),
            i, j, k, l, m, n, o, p, q, r, s, t, u;
        for (;;) {
            f.empty() || (i = f.min());
            if (h && (f.empty() || h.y < i.y || h.y == i.y && h.x < i.x)) j = d.leftBound(h), k = d.right(j), o = d.rightRegion(j), t = e.bisect(o, h), n = d.createHalfEdge(t, "l"), d.insert(j, n), r = e.intersect(j, n), r && (f.del(j), f.insert(j, r, e.distance(r, h))), j = n, n = d.createHalfEdge(t, "r"), d.insert(j, n), r = e.intersect(n, k), r && f.insert(n, r, e.distance(r, h)), h = c.list.shift();
            else if (!f.empty()) j = f.extractMin(), l = d.left(j), k = d.right(j), m = d.right(k), o = d.leftRegion(j), p = d.rightRegion(k), s = j.vertex, e.endPoint(j.edge, j.side, s), e.endPoint(k.edge, k.side, s), d.del(j), f.del(k), d.del(k), u = "l", o.y > p.y && (q = o, o = p, p = q, u = "r"), t = e.bisect(o, p), n = d.createHalfEdge(t, u), d.insert(l, n), e.endPoint(t, g[u], s), r = e.intersect(l, n), r && (f.del(l), f.insert(l, r, e.distance(r, o))), r = e.intersect(n, m), r && f.insert(n, r, e.distance(r, o));
            else break
        }
        for (j = d.right(d.leftEnd); j != d.rightEnd; j = d.right(j)) b(j.edge)
    }

    function i() {
        return {
            leaf: !0,
            nodes: [],
            point: null
        }
    }

    function j(a, b, c, d, e, f) {
        if (!a(b, c, d, e, f)) {
            var g = (c + e) * .5,
                h = (d + f) * .5,
                i = b.nodes;
            i[0] && j(a, i[0], c, d, g, h), i[1] && j(a, i[1], g, d, e, h), i[2] && j(a, i[2], c, h, g, f), i[3] && j(a, i[3], g, h, e, f)
        }
    }

    function k(a) {
        return {
            x: a[0],
            y: a[1]
        }
    }
    d3.geom = {}, d3.geom.contour = function(d, e) {
        var f = e || c(d),
            g = [],
            h = f[0],
            i = f[1],
            j = 0,
            k = 0,
            l = NaN,
            m = NaN,
            n = 0;
        do n = 0, d(h - 1, i - 1) && (n += 1), d(h, i - 1) && (n += 2), d(h - 1, i) && (n += 4), d(h, i) && (n += 8), n === 6 ? (j = m === -1 ? -1 : 1, k = 0) : n === 9 ? (j = 0, k = l === 1 ? -1 : 1) : (j = a[n], k = b[n]), j != l && k != m && (g.push([h, i]), l = j, m = k), h += j, i += k; while (f[0] != h || f[1] != i);
        return g
    };
    var a = [1, 0, 1, 1, -1, 0, -1, 1, 0, 0, 0, 0, -1, 0, -1, NaN],
        b = [0, -1, 0, 0, 0, -1, 0, 0, 1, -1, 1, 1, 0, -1, 0, NaN];
    d3.geom.hull = function(a) {
        if (a.length < 3) return [];
        var b = a.length,
            c = b - 1,
            e = [],
            f = [],
            g, h, i = 0,
            j, k, l, m, n, o, p, q;
        for (g = 1; g < b; ++g) a[g][1] < a[i][1] ? i = g : a[g][1] == a[i][1] && (i = a[g][0] < a[i][0] ? g : i);
        for (g = 0; g < b; ++g) {
            if (g === i) continue;
            k = a[g][1] - a[i][1], j = a[g][0] - a[i][0], e.push({
                angle: Math.atan2(k, j),
                index: g
            })
        }
        e.sort(function(a, b) {
            return a.angle - b.angle
        }), p = e[0].angle, o = e[0].index, n = 0;
        for (g = 1; g < c; ++g) h = e[g].index, p == e[g].angle ? (j = a[o][0] - a[i][0], k = a[o][1] - a[i][1], l = a[h][0] - a[i][0], m = a[h][1] - a[i][1], j * j + k * k >= l * l + m * m ? e[g].index = -1 : (e[n].index = -1, p = e[g].angle, n = g, o = h)) : (p = e[g].angle, n = g, o = h);
        f.push(i);
        for (g = 0, h = 0; g < 2; ++h) e[h].index !== -1 && (f.push(e[h].index), g++);
        q = f.length;
        for (; h < c; ++h) {
            if (e[h].index === -1) continue;
            while (!d(f[q - 2], f[q - 1], e[h].index, a)) --q;
            f[q++] = e[h].index
        }
        var r = [];
        for (g = 0; g < q; ++g) r.push(a[f[g]]);
        return r
    }, d3.geom.polygon = function(a) {
        return a.area = function() {
            var b = 0,
                c = a.length,
                d = a[c - 1][0] * a[0][1],
                e = a[c - 1][1] * a[0][0];
            while (++b < c) d += a[b - 1][0] * a[b][1], e += a[b - 1][1] * a[b][0];
            return (e - d) * .5
        }, a.centroid = function(b) {
            var c = -1,
                d = a.length,
                e = 0,
                f = 0,
                g, h = a[d - 1],
                i;
            arguments.length || (b = -1 / (6 * a.area()));
            while (++c < d) g = h, h = a[c], i = g[0] * h[1] - h[0] * g[1], e += (g[0] + h[0]) * i, f += (g[1] + h[1]) * i;
            return [e * b, f * b]
        }, a.clip = function(b) {
            var c, d = -1,
                g = a.length,
                h, i, j = a[g - 1],
                k, l, m;
            while (++d < g) {
                c = b.slice(), b.length = 0, k = a[d], l = c[(i = c.length) - 1], h = -1;
                while (++h < i) m = c[h], e(m, j, k) ? (e(l, j, k) || b.push(f(l, m, j, k)), b.push(m)) : e(l, j, k) && b.push(f(l, m, j, k)), l = m;
                j = k
            }
            return b
        }, a
    }, d3.geom.voronoi = function(a) {
        var b = a.map(function() {
            return []
        });
        return h(a, function(a) {
            var c, d, e, f, g, h;
            a.a === 1 && a.b >= 0 ? (c = a.ep.r, d = a.ep.l) : (c = a.ep.l, d = a.ep.r), a.a === 1 ? (g = c ? c.y : -1e6, e = a.c - a.b * g, h = d ? d.y : 1e6, f = a.c - a.b * h) : (e = c ? c.x : -1e6, g = a.c - a.a * e, f = d ? d.x : 1e6, h = a.c - a.a * f);
            var i = [e, g],
                j = [f, h];
            b[a.region.l.index].push(i, j), b[a.region.r.index].push(i, j)
        }), b.map(function(b, c) {
            var d = a[c][0],
                e = a[c][1];
            return b.forEach(function(a) {
                a.angle = Math.atan2(a[0] - d, a[1] - e)
            }), b.sort(function(a, b) {
                return a.angle - b.angle
            }).filter(function(a, c) {
                return !c || a.angle - b[c - 1].angle > 1e-10
            })
        })
    };
    var g = {
        l: "r",
        r: "l"
    };
    d3.geom.delaunay = function(a) {
        var b = a.map(function() {
                return []
            }),
            c = [];
        return h(a, function(c) {
            b[c.region.l.index].push(a[c.region.r.index])
        }), b.forEach(function(b, d) {
            var e = a[d],
                f = e[0],
                g = e[1];
            b.forEach(function(a) {
                a.angle = Math.atan2(a[0] - f, a[1] - g)
            }), b.sort(function(a, b) {
                return a.angle - b.angle
            });
            for (var h = 0, i = b.length - 1; h < i; h++) c.push([e, b[h], b[h + 1]])
        }), c
    }, d3.geom.quadtree = function(a, b, c, d, e) {
        function n(a, b, c, d, e, f) {
            if (isNaN(b.x) || isNaN(b.y)) return;
            if (a.leaf) {
                var g = a.point;
                g ? Math.abs(g.x - b.x) + Math.abs(g.y - b.y) < .01 ? o(a, b, c, d, e, f) : (a.point = null, o(a, g, c, d, e, f), o(a, b, c, d, e, f)) : a.point = b
            } else o(a, b, c, d, e, f)
        }

        function o(a, b, c, d, e, f) {
            var g = (c + e) * .5,
                h = (d + f) * .5,
                j = b.x >= g,
                k = b.y >= h,
                l = (k << 1) + j;
            a.leaf = !1, a = a.nodes[l] || (a.nodes[l] = i()), j ? c = g : e = g, k ? d = h : f = h, n(a, b, c, d, e, f)
        }
        var f, g = -1,
            h = a.length;
        h && isNaN(a[0].x) && (a = a.map(k));
        if (arguments.length < 5)
            if (arguments.length === 3) e = d = c, c = b;
            else {
                b = c = Infinity, d = e = -Infinity;
                while (++g < h) f = a[g], f.x < b && (b = f.x), f.y < c && (c = f.y), f.x > d && (d = f.x), f.y > e && (e = f.y);
                var l = d - b,
                    m = e - c;
                l > m ? e = c + l : d = b + m
            }
        var p = i();
        return p.add = function(a) {
            n(p, a, b, c, d, e)
        }, p.visit = function(a) {
            j(a, p, b, c, d, e)
        }, a.forEach(p.add), p
    }
})();


/********************************
 ** FILE: lib/d3.layout.min.js
 ********************************/

(function() {
    function a(a) {
        var b = a.source,
            d = a.target,
            e = c(b, d),
            f = [b];
        while (b !== e) b = b.parent, f.push(b);
        var g = f.length;
        while (d !== e) f.splice(g, 0, d), d = d.parent;
        return f
    }

    function b(a) {
        var b = [],
            c = a.parent;
        while (c != null) b.push(a), a = c, c = c.parent;
        return b.push(a), b
    }

    function c(a, c) {
        if (a === c) return a;
        var d = b(a),
            e = b(c),
            f = d.pop(),
            g = e.pop(),
            h = null;
        while (f === g) h = f, f = d.pop(), g = e.pop();
        return h
    }

    function g(a) {
        a.fixed |= 2
    }

    function h(a) {
        a !== f && (a.fixed &= 1)
    }

    function i() {
        j(), f.fixed &= 1, e = f = null
    }

    function j() {
        f.px = d3.event.x, f.py = d3.event.y, e.resume()
    }

    function k(a, b, c) {
        var d = 0,
            e = 0;
        a.charge = 0;
        if (!a.leaf) {
            var f = a.nodes,
                g = f.length,
                h = -1,
                i;
            while (++h < g) {
                i = f[h];
                if (i == null) continue;
                k(i, b, c), a.charge += i.charge, d += i.charge * i.cx, e += i.charge * i.cy
            }
        }
        if (a.point) {
            a.leaf || (a.point.x += Math.random() - .5, a.point.y += Math.random() - .5);
            var j = b * c[a.point.index];
            a.charge += a.pointCharge = j, d += j * a.point.x, e += j * a.point.y
        }
        a.cx = d / a.charge, a.cy = e / a.charge
    }

    function l(a) {
        return 20
    }

    function m(a) {
        return 1
    }

    function o(a) {
        return a.x
    }

    function p(a) {
        return a.y
    }

    function q(a, b, c) {
        a.y0 = b, a.y = c
    }

    function t(a) {
        var b = 1,
            c = 0,
            d = a[0][1],
            e, f = a.length;
        for (; b < f; ++b)(e = a[b][1]) > d && (c = b, d = e);
        return c
    }

    function u(a) {
        return a.reduce(v, 0)
    }

    function v(a, b) {
        return a + b[1]
    }

    function w(a, b) {
        return x(a, Math.ceil(Math.log(b.length) / Math.LN2 + 1))
    }

    function x(a, b) {
        var c = -1,
            d = +a[0],
            e = (a[1] - d) / b,
            f = [];
        while (++c <= b) f[c] = e * c + d;
        return f
    }

    function y(a) {
        return [d3.min(a), d3.max(a)]
    }

    function z(a, b) {
        return d3.rebind(a, b, "sort", "children", "value"), a.links = D, a.nodes = function(b) {
            return E = !0, (a.nodes = a)(b)
        }, a
    }

    function A(a) {
        return a.children
    }

    function B(a) {
        return a.value
    }

    function C(a, b) {
        return b.value - a.value
    }

    function D(a) {
        return d3.merge(a.map(function(a) {
            return (a.children || []).map(function(b) {
                return {
                    source: a,
                    target: b
                }
            })
        }))
    }

    function F(a, b) {
        return a.value - b.value
    }

    function G(a, b) {
        var c = a._pack_next;
        a._pack_next = b, b._pack_prev = a, b._pack_next = c, c._pack_prev = b
    }

    function H(a, b) {
        a._pack_next = b, b._pack_prev = a
    }

    function I(a, b) {
        var c = b.x - a.x,
            d = b.y - a.y,
            e = a.r + b.r;
        return e * e - c * c - d * d > .001
    }

    function J(a) {
        function l(a) {
            b = Math.min(a.x - a.r, b), c = Math.max(a.x + a.r, c), d = Math.min(a.y - a.r, d), e = Math.max(a.y + a.r, e)
        }
        var b = Infinity,
            c = -Infinity,
            d = Infinity,
            e = -Infinity,
            f = a.length,
            g, h, i, j, k;
        a.forEach(K), g = a[0], g.x = -g.r, g.y = 0, l(g);
        if (f > 1) {
            h = a[1], h.x = h.r, h.y = 0, l(h);
            if (f > 2) {
                i = a[2], O(g, h, i), l(i), G(g, i), g._pack_prev = i, G(i, h), h = g._pack_next;
                for (var m = 3; m < f; m++) {
                    O(g, h, i = a[m]);
                    var n = 0,
                        o = 1,
                        p = 1;
                    for (j = h._pack_next; j !== h; j = j._pack_next, o++)
                        if (I(j, i)) {
                            n = 1;
                            break
                        }
                    if (n == 1)
                        for (k = g._pack_prev; k !== j._pack_prev; k = k._pack_prev, p++)
                            if (I(k, i)) break;
                    n ? (o < p || o == p && h.r < g.r ? H(g, h = j) : H(g = k, h), m--) : (G(g, i), h = i, l(i))
                }
            }
        }
        var q = (b + c) / 2,
            r = (d + e) / 2,
            s = 0;
        for (var m = 0; m < f; m++) {
            var t = a[m];
            t.x -= q, t.y -= r, s = Math.max(s, t.r + Math.sqrt(t.x * t.x + t.y * t.y))
        }
        return a.forEach(L), s
    }

    function K(a) {
        a._pack_next = a._pack_prev = a
    }

    function L(a) {
        delete a._pack_next, delete a._pack_prev
    }

    function M(a) {
        var b = a.children;
        b && b.length ? (b.forEach(M), a.r = J(b)) : a.r = Math.sqrt(a.value)
    }

    function N(a, b, c, d) {
        var e = a.children;
        a.x = b += d * a.x, a.y = c += d * a.y, a.r *= d;
        if (e) {
            var f = -1,
                g = e.length;
            while (++f < g) N(e[f], b, c, d)
        }
    }

    function O(a, b, c) {
        var d = a.r + c.r,
            e = b.x - a.x,
            f = b.y - a.y;
        if (d && (e || f)) {
            var g = b.r + c.r,
                h = Math.sqrt(e * e + f * f),
                i = Math.max(-1, Math.min(1, (d * d + h * h - g * g) / (2 * d * h))),
                j = Math.acos(i),
                k = i * (d /= h),
                l = Math.sin(j) * d;
            c.x = a.x + k * e + l * f, c.y = a.y + k * f - l * e
        } else c.x = a.x + d, c.y = a.y
    }

    function P(a) {
        return 1 + d3.max(a, function(a) {
            return a.y
        })
    }

    function Q(a) {
        return a.reduce(function(a, b) {
            return a + b.x
        }, 0) / a.length
    }

    function R(a) {
        var b = a.children;
        return b && b.length ? R(b[0]) : a
    }

    function S(a) {
        var b = a.children,
            c;
        return b && (c = b.length) ? S(b[c - 1]) : a
    }

    function T(a, b) {
        return a.parent == b.parent ? 1 : 2
    }

    function U(a) {
        var b = a.children;
        return b && b.length ? b[0] : a._tree.thread
    }

    function V(a) {
        var b = a.children,
            c;
        return b && (c = b.length) ? b[c - 1] : a._tree.thread
    }

    function W(a, b) {
        var c = a.children;
        if (c && (e = c.length)) {
            var d, e, f = -1;
            while (++f < e) b(d = W(c[f], b), a) > 0 && (a = d)
        }
        return a
    }

    function X(a, b) {
        return a.x - b.x
    }

    function Y(a, b) {
        return b.x - a.x
    }

    function Z(a, b) {
        return a.depth - b.depth
    }

    function $(a, b) {
        function c(a, d) {
            var e = a.children;
            if (e && (i = e.length)) {
                var f, g = null,
                    h = -1,
                    i;
                while (++h < i) f = e[h], c(f, g), g = f
            }
            b(a, d)
        }
        c(a, null)
    }

    function _(a) {
        var b = 0,
            c = 0,
            d = a.children,
            e = d.length,
            f;
        while (--e >= 0) f = d[e]._tree, f.prelim += b, f.mod += b, b += f.shift + (c += f.change)
    }

    function ba(a, b, c) {
        a = a._tree, b = b._tree;
        var d = c / (b.number - a.number);
        a.change += d, b.change -= d, b.shift += c, b.prelim += c, b.mod += c
    }

    function bb(a, b, c) {
        return a._tree.ancestor.parent == b.parent ? a._tree.ancestor : c
    }

    function bc(a) {
        return {
            x: a.x,
            y: a.y,
            dx: a.dx,
            dy: a.dy
        }
    }

    function bd(a, b) {
        var c = a.x + b[3],
            d = a.y + b[0],
            e = a.dx - b[1] - b[3],
            f = a.dy - b[0] - b[2];
        return e < 0 && (c += e / 2, e = 0), f < 0 && (d += f / 2, f = 0), {
            x: c,
            y: d,
            dx: e,
            dy: f
        }
    }
    d3.layout = {}, d3.layout.bundle = function() {
        return function(b) {
            var c = [],
                d = -1,
                e = b.length;
            while (++d < e) c.push(a(b[d]));
            return c
        }
    }, d3.layout.chord = function() {
        function j() {
            var a = {},
                j = [],
                l = d3.range(e),
                m = [],
                n, o, p, q, r;
            b = [], c = [], n = 0, q = -1;
            while (++q < e) {
                o = 0, r = -1;
                while (++r < e) o += d[q][r];
                j.push(o), m.push(d3.range(e)), n += o
            }
            g && l.sort(function(a, b) {
                return g(j[a], j[b])
            }), h && m.forEach(function(a, b) {
                a.sort(function(a, c) {
                    return h(d[b][a], d[b][c])
                })
            }), n = (2 * Math.PI - f * e) / n, o = 0, q = -1;
            while (++q < e) {
                p = o, r = -1;
                while (++r < e) {
                    var s = l[q],
                        t = m[s][r],
                        u = d[s][t],
                        v = o,
                        w = o += u * n;
                    a[s + "-" + t] = {
                        index: s,
                        subindex: t,
                        startAngle: v,
                        endAngle: w,
                        value: u
                    }
                }
                c.push({
                    index: s,
                    startAngle: p,
                    endAngle: o,
                    value: (o - p) / n
                }), o += f
            }
            q = -1;
            while (++q < e) {
                r = q - 1;
                while (++r < e) {
                    var x = a[q + "-" + r],
                        y = a[r + "-" + q];
                    (x.value || y.value) && b.push(x.value < y.value ? {
                        source: y,
                        target: x
                    } : {
                        source: x,
                        target: y
                    })
                }
            }
            i && k()
        }

        function k() {
            b.sort(function(a, b) {
                return i((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2)
            })
        }
        var a = {},
            b, c, d, e, f = 0,
            g, h, i;
        return a.matrix = function(f) {
            return arguments.length ? (e = (d = f) && d.length, b = c = null, a) : d
        }, a.padding = function(d) {
            return arguments.length ? (f = d, b = c = null, a) : f
        }, a.sortGroups = function(d) {
            return arguments.length ? (g = d, b = c = null, a) : g
        }, a.sortSubgroups = function(c) {
            return arguments.length ? (h = c, b = null, a) : h
        }, a.sortChords = function(c) {
            return arguments.length ? (i = c, b && k(), a) : i
        }, a.chords = function() {
            return b || j(), b
        }, a.groups = function() {
            return c || j(), c
        }, a
    }, d3.layout.force = function() {
        function A(a) {
            return function(b, c, d, e, f) {
                if (b.point !== a) {
                    var g = b.cx - a.x,
                        h = b.cy - a.y,
                        i = 1 / Math.sqrt(g * g + h * h);
                    if ((e - c) * i < t) {
                        var j = b.charge * i * i;
                        return a.px -= g * j, a.py -= h * j, !0
                    }
                    if (b.point && isFinite(i)) {
                        var j = b.pointCharge * i * i;
                        a.px -= g * j, a.py -= h * j
                    }
                }
                return !b.charge
            }
        }

        function B() {
            var a = v.length,
                d = w.length,
                e, f, g, h, i, j, l, m, p;
            for (f = 0; f < d; ++f) {
                g = w[f], h = g.source, i = g.target, m = i.x - h.x, p = i.y - h.y;
                if (j = m * m + p * p) j = n * y[f] * ((j = Math.sqrt(j)) - x[f]) / j, m *= j, p *= j, i.x -= m * (l = h.weight / (i.weight + h.weight)), i.y -= p * l, h.x += m * (l = 1 - l), h.y += p * l
            }
            if (l = n * s) {
                m = c[0] / 2, p = c[1] / 2, f = -1;
                if (l)
                    while (++f < a) g = v[f], g.x += (m - g.x) * l, g.y += (p - g.y) * l
            }
            if (r) {
                k(e = d3.geom.quadtree(v), n, z), f = -1;
                while (++f < a)(g = v[f]).fixed || e.visit(A(g))
            }
            f = -1;
            while (++f < a) g = v[f], g.fixed ? (g.x = g.px, g.y = g.py) : (g.x -= (g.px - (g.px = g.x)) * o, g.y -= (g.py - (g.py = g.y)) * o);
            return b.tick({
                type: "tick",
                alpha: n
            }), (n *= .99) < .005
        }

        function C(b) {
            g(f = b), e = a
        }
        var a = {},
            b = d3.dispatch("tick"),
            c = [1, 1],
            d, n, o = .9,
            p = l,
            q = m,
            r = -30,
            s = .1,
            t = .8,
            u, v = [],
            w = [],
            x, y, z;
        return a.nodes = function(b) {
            return arguments.length ? (v = b, a) : v
        }, a.links = function(b) {
            return arguments.length ? (w = b, a) : w
        }, a.size = function(b) {
            return arguments.length ? (c = b, a) : c
        }, a.linkDistance = function(b) {
            return arguments.length ? (p = d3.functor(b), a) : p
        }, a.distance = a.linkDistance, a.linkStrength = function(b) {
            return arguments.length ? (q = d3.functor(b), a) : q
        }, a.friction = function(b) {
            return arguments.length ? (o = b, a) : o
        }, a.charge = function(b) {
            return arguments.length ? (r = typeof b == "function" ? b : +b, a) : r
        }, a.gravity = function(b) {
            return arguments.length ? (s = b, a) : s
        }, a.theta = function(b) {
            return arguments.length ? (t = b, a) : t
        }, a.start = function() {
            function k(a, c) {
                var d = l(b),
                    e = -1,
                    f = d.length,
                    g;
                while (++e < f)
                    if (!isNaN(g = d[e][a])) return g;
                return Math.random() * c
            }

            function l() {
                if (!i) {
                    i = [];
                    for (d = 0; d < e; ++d) i[d] = [];
                    for (d = 0; d < f; ++d) {
                        var a = w[d];
                        i[a.source.index].push(a.target), i[a.target.index].push(a.source)
                    }
                }
                return i[b]
            }
            var b, d, e = v.length,
                f = w.length,
                g = c[0],
                h = c[1],
                i, j;
            for (b = 0; b < e; ++b)(j = v[b]).index = b, j.weight = 0;
            x = [], y = [];
            for (b = 0; b < f; ++b) j = w[b], typeof j.source == "number" && (j.source = v[j.source]), typeof j.target == "number" && (j.target = v[j.target]), x[b] = p.call(this, j, b), y[b] = q.call(this, j, b), ++j.source.weight, ++j.target.weight;
            for (b = 0; b < e; ++b) j = v[b], isNaN(j.x) && (j.x = k("x", g)), isNaN(j.y) && (j.y = k("y", h)), isNaN(j.px) && (j.px = j.x), isNaN(j.py) && (j.py = j.y);
            z = [];
            if (typeof r == "function")
                for (b = 0; b < e; ++b) z[b] = +r.call(this, v[b], b);
            else
                for (b = 0; b < e; ++b) z[b] = r;
            return a.resume()
        }, a.resume = function() {
            return n = .1, d3.timer(B), a
        }, a.stop = function() {
            return n = 0, a
        }, a.drag = function() {
            d || (d = d3.behavior.drag().origin(Object).on("dragstart", C).on("drag", j).on("dragend", i)), this.on("mouseover.force", g).on("mouseout.force", h).call(d)
        }, d3.rebind(a, b, "on")
    };
    var e, f;
    d3.layout.partition = function() {
        function c(a, b, d, e) {
            var f = a.children;
            a.x = b, a.y = a.depth * e, a.dx = d, a.dy = e;
            if (f && (h = f.length)) {
                var g = -1,
                    h, i, j;
                d = a.value ? d / a.value : 0;
                while (++g < h) c(i = f[g], b, j = i.value * d, e), b += j
            }
        }

        function d(a) {
            var b = a.children,
                c = 0;
            if (b && (f = b.length)) {
                var e = -1,
                    f;
                while (++e < f) c = Math.max(c, d(b[e]))
            }
            return 1 + c
        }

        function e(e, f) {
            var g = a.call(this, e, f);
            return c(g[0], 0, b[0], b[1] / d(g[0])), g
        }
        var a = d3.layout.hierarchy(),
            b = [1, 1];
        return e.size = function(a) {
            return arguments.length ? (b = a, e) : b
        }, z(e, a)
    }, d3.layout.pie = function() {
        function f(g, h) {
            var i = g.map(function(b, c) {
                    return +a.call(f, b, c)
                }),
                j = +(typeof c == "function" ? c.apply(this, arguments) : c),
                k = ((typeof e == "function" ? e.apply(this, arguments) : e) - c) / d3.sum(i),
                l = d3.range(g.length);
            b != null && l.sort(b === n ? function(a, b) {
                return i[b] - i[a]
            } : function(a, c) {
                return b(g[a], g[c])
            });
            var m = [];
            return l.forEach(function(a) {
                m[a] = {
                    data: g[a],
                    value: d = i[a],
                    startAngle: j,
                    endAngle: j += d * k
                }
            }), m
        }
        var a = Number,
            b = n,
            c = 0,
            e = 2 * Math.PI;
        return f.value = function(b) {
            return arguments.length ? (a = b, f) : a
        }, f.sort = function(a) {
            return arguments.length ? (b = a, f) : b
        }, f.startAngle = function(a) {
            return arguments.length ? (c = a, f) : c
        }, f.endAngle = function(a) {
            return arguments.length ? (e = a, f) : e
        }, f
    };
    var n = {};
    d3.layout.stack = function() {
        function g(h, i) {
            var j = h.map(function(b, c) {
                    return a.call(g, b, c)
                }),
                k = j.map(function(a, b) {
                    return a.map(function(a, b) {
                        return [e.call(g, a, b), f.call(g, a, b)]
                    })
                }),
                l = b.call(g, k, i);
            j = d3.permute(j, l), k = d3.permute(k, l);
            var m = c.call(g, k, i),
                n = j.length,
                o = j[0].length,
                p, q, r;
            for (q = 0; q < o; ++q) {
                d.call(g, j[0][q], r = m[q], k[0][q][1]);
                for (p = 1; p < n; ++p) d.call(g, j[p][q], r += k[p - 1][q][1], k[p][q][1])
            }
            return h
        }
        var a = Object,
            b = r["default"],
            c = s.zero,
            d = q,
            e = o,
            f = p;
        return g.values = function(b) {
            return arguments.length ? (a = b, g) : a
        }, g.order = function(a) {
            return arguments.length ? (b = typeof a == "function" ? a : r[a], g) : b
        }, g.offset = function(a) {
            return arguments.length ? (c = typeof a == "function" ? a : s[a], g) : c
        }, g.x = function(a) {
            return arguments.length ? (e = a, g) : e
        }, g.y = function(a) {
            return arguments.length ? (f = a, g) : f
        }, g.out = function(a) {
            return arguments.length ? (d = a, g) : d
        }, g
    };
    var r = {
            "inside-out": function(a) {
                var b = a.length,
                    c, d, e = a.map(t),
                    f = a.map(u),
                    g = d3.range(b).sort(function(a, b) {
                        return e[a] - e[b]
                    }),
                    h = 0,
                    i = 0,
                    j = [],
                    k = [];
                for (c = 0; c < b; ++c) d = g[c], h < i ? (h += f[d], j.push(d)) : (i += f[d], k.push(d));
                return k.reverse().concat(j)
            },
            reverse: function(a) {
                return d3.range(a.length).reverse()
            },
            "default": function(a) {
                return d3.range(a.length)
            }
        },
        s = {
            silhouette: function(a) {
                var b = a.length,
                    c = a[0].length,
                    d = [],
                    e = 0,
                    f, g, h, i = [];
                for (g = 0; g < c; ++g) {
                    for (f = 0, h = 0; f < b; f++) h += a[f][g][1];
                    h > e && (e = h), d.push(h)
                }
                for (g = 0; g < c; ++g) i[g] = (e - d[g]) / 2;
                return i
            },
            wiggle: function(a) {
                var b = a.length,
                    c = a[0],
                    d = c.length,
                    e = 0,
                    f, g, h, i, j, k, l, m, n, o = [];
                o[0] = m = n = 0;
                for (g = 1; g < d; ++g) {
                    for (f = 0, i = 0; f < b; ++f) i += a[f][g][1];
                    for (f = 0, j = 0, l = c[g][0] - c[g - 1][0]; f < b; ++f) {
                        for (h = 0, k = (a[f][g][1] - a[f][g - 1][1]) / (2 * l); h < f; ++h) k += (a[h][g][1] - a[h][g - 1][1]) / l;
                        j += k * a[f][g][1]
                    }
                    o[g] = m -= i ? j / i * l : 0, m < n && (n = m)
                }
                for (g = 0; g < d; ++g) o[g] -= n;
                return o
            },
            expand: function(a) {
                var b = a.length,
                    c = a[0].length,
                    d = 1 / b,
                    e, f, g, h = [];
                for (f = 0; f < c; ++f) {
                    for (e = 0, g = 0; e < b; e++) g += a[e][f][1];
                    if (g)
                        for (e = 0; e < b; e++) a[e][f][1] /= g;
                    else
                        for (e = 0; e < b; e++) a[e][f][1] = d
                }
                for (f = 0; f < c; ++f) h[f] = 0;
                return h
            },
            zero: function(a) {
                var b = -1,
                    c = a[0].length,
                    d = [];
                while (++b < c) d[b] = 0;
                return d
            }
        };
    d3.layout.histogram = function() {
        function e(e, f) {
            var g = [],
                h = e.map(b, this),
                i = c.call(this, h, f),
                j = d.call(this, i, h, f),
                k, f = -1,
                l = h.length,
                m = j.length - 1,
                n = a ? 1 : 1 / l,
                o;
            while (++f < m) k = g[f] = [], k.dx = j[f + 1] - (k.x = j[f]), k.y = 0;
            f = -1;
            while (++f < l) o = h[f], o >= i[0] && o <= i[1] && (k = g[d3.bisect(j, o, 1, m) - 1], k.y += n, k.push(e[f]));
            return g
        }
        var a = !0,
            b = Number,
            c = y,
            d = w;
        return e.value = function(a) {
            return arguments.length ? (b = a, e) : b
        }, e.range = function(a) {
            return arguments.length ? (c = d3.functor(a), e) : c
        }, e.bins = function(a) {
            return arguments.length ? (d = typeof a == "number" ? function(b) {
                return x(b, a)
            } : d3.functor(a), e) : d
        }, e.frequency = function(b) {
            return arguments.length ? (a = !!b, e) : a
        }, e
    }, d3.layout.hierarchy = function() {
        function e(f, h, i) {
            var j = b.call(g, f, h),
                k = E ? f : {
                    data: f
                };
            k.depth = h, i.push(k);
            if (j && (m = j.length)) {
                var l = -1,
                    m, n = k.children = [],
                    o = 0,
                    p = h + 1;
                while (++l < m) d = e(j[l], p, i), d.parent = k, n.push(d), o += d.value;
                a && n.sort(a), c && (k.value = o)
            } else c && (k.value = +c.call(g, f, h) || 0);
            return k
        }

        function f(a, b) {
            var d = a.children,
                e = 0;
            if (d && (i = d.length)) {
                var h = -1,
                    i, j = b + 1;
                while (++h < i) e += f(d[h], j)
            } else c && (e = +c.call(g, E ? a : a.data, b) || 0);
            return c && (a.value = e), e
        }

        function g(a) {
            var b = [];
            return e(a, 0, b), b
        }
        var a = C,
            b = A,
            c = B;
        return g.sort = function(b) {
            return arguments.length ? (a = b, g) : a
        }, g.children = function(a) {
            return arguments.length ? (b = a, g) : b
        }, g.value = function(a) {
            return arguments.length ? (c = a, g) : c
        }, g.revalue = function(a) {
            return f(a, 0), a
        }, g
    };
    var E = !1;
    d3.layout.pack = function() {
        function c(c, d) {
            var e = a.call(this, c, d),
                f = e[0];
            f.x = 0, f.y = 0, M(f);
            var g = b[0],
                h = b[1],
                i = 1 / Math.max(2 * f.r / g, 2 * f.r / h);
            return N(f, g / 2, h / 2, i), e
        }
        var a = d3.layout.hierarchy().sort(F),
            b = [1, 1];
        return c.size = function(a) {
            return arguments.length ? (b = a, c) : b
        }, z(c, a)
    }, d3.layout.cluster = function() {
        function d(d, e) {
            var f = a.call(this, d, e),
                g = f[0],
                h, i = 0,
                j, k;
            $(g, function(a) {
                var c = a.children;
                c && c.length ? (a.x = Q(c), a.y = P(c)) : (a.x = h ? i += b(a, h) : 0, a.y = 0, h = a)
            });
            var l = R(g),
                m = S(g),
                n = l.x - b(l, m) / 2,
                o = m.x + b(m, l) / 2;
            return $(g, function(a) {
                a.x = (a.x - n) / (o - n) * c[0], a.y = (1 - (g.y ? a.y / g.y : 1)) * c[1]
            }), f
        }
        var a = d3.layout.hierarchy().sort(null).value(null),
            b = T,
            c = [1, 1];
        return d.separation = function(a) {
            return arguments.length ? (b = a, d) : b
        }, d.size = function(a) {
            return arguments.length ? (c = a, d) : c
        }, z(d, a)
    }, d3.layout.tree = function() {
        function d(d, e) {
            function h(a, c) {
                var d = a.children,
                    e = a._tree;
                if (d && (f = d.length)) {
                    var f, g = d[0],
                        i, k = g,
                        l, m = -1;
                    while (++m < f) l = d[m], h(l, i), k = j(l, i, k), i = l;
                    _(a);
                    var n = .5 * (g._tree.prelim + l._tree.prelim);
                    c ? (e.prelim = c._tree.prelim + b(a, c), e.mod = e.prelim - n) : e.prelim = n
                } else c && (e.prelim = c._tree.prelim + b(a, c))
            }

            function i(a, b) {
                a.x = a._tree.prelim + b;
                var c = a.children;
                if (c && (e = c.length)) {
                    var d = -1,
                        e;
                    b += a._tree.mod;
                    while (++d < e) i(c[d], b)
                }
            }

            function j(a, c, d) {
                if (c) {
                    var e = a,
                        f = a,
                        g = c,
                        h = a.parent.children[0],
                        i = e._tree.mod,
                        j = f._tree.mod,
                        k = g._tree.mod,
                        l = h._tree.mod,
                        m;
                    while (g = V(g), e = U(e), g && e) h = U(h), f = V(f), f._tree.ancestor = a, m = g._tree.prelim + k - e._tree.prelim - i + b(g, e), m > 0 && (ba(bb(g, a, d), a, m), i += m, j += m), k += g._tree.mod, i += e._tree.mod, l += h._tree.mod, j += f._tree.mod;
                    g && !V(f) && (f._tree.thread = g, f._tree.mod += k - j), e && !U(h) && (h._tree.thread = e, h._tree.mod += i - l, d = a)
                }
                return d
            }
            var f = a.call(this, d, e),
                g = f[0];
            $(g, function(a, b) {
                a._tree = {
                    ancestor: a,
                    prelim: 0,
                    mod: 0,
                    change: 0,
                    shift: 0,
                    number: b ? b._tree.number + 1 : 0
                }
            }), h(g), i(g, -g._tree.prelim);
            var k = W(g, Y),
                l = W(g, X),
                m = W(g, Z),
                n = k.x - b(k, l) / 2,
                o = l.x + b(l, k) / 2,
                p = m.depth || 1;
            return $(g, function(a) {
                a.x = (a.x - n) / (o - n) * c[0], a.y = a.depth / p * c[1], delete a._tree
            }), f
        }
        var a = d3.layout.hierarchy().sort(null).value(null),
            b = T,
            c = [1, 1];
        return d.separation = function(a) {
            return arguments.length ? (b = a, d) : b
        }, d.size = function(a) {
            return arguments.length ? (c = a, d) : c
        }, z(d, a)
    }, d3.layout.treemap = function() {
        function i(a, b) {
            var c = -1,
                d = a.length,
                e, f;
            while (++c < d) f = (e = a[c]).value * (b < 0 ? 0 : b), e.area = isNaN(f) || f <= 0 ? 0 : f
        }

        function j(a) {
            var b = a.children;
            if (b && b.length) {
                var c = e(a),
                    d = [],
                    f = b.slice(),
                    g, h = Infinity,
                    k, n = Math.min(c.dx, c.dy),
                    o;
                i(f, c.dx * c.dy / a.value), d.area = 0;
                while ((o = f.length) > 0) d.push(g = f[o - 1]), d.area += g.area, (k = l(d, n)) <= h ? (f.pop(), h = k) : (d.area -= d.pop().area, m(d, n, c, !1), n = Math.min(c.dx, c.dy), d.length = d.area = 0, h = Infinity);
                d.length && (m(d, n, c, !0), d.length = d.area = 0), b.forEach(j)
            }
        }

        function k(a) {
            var b = a.children;
            if (b && b.length) {
                var c = e(a),
                    d = b.slice(),
                    f, g = [];
                i(d, c.dx * c.dy / a.value), g.area = 0;
                while (f = d.pop()) g.push(f), g.area += f.area, f.z != null && (m(g, f.z ? c.dx : c.dy, c, !d.length), g.length = g.area = 0);
                b.forEach(k)
            }
        }

        function l(a, b) {
            var c = a.area,
                d, e = 0,
                f = Infinity,
                g = -1,
                i = a.length;
            while (++g < i) {
                if (!(d = a[g].area)) continue;
                d < f && (f = d), d > e && (e = d)
            }
            return c *= c, b *= b, c ? Math.max(b * e * h / c, c / (b * f * h)) : Infinity
        }

        function m(a, c, d, e) {
            var f = -1,
                g = a.length,
                h = d.x,
                i = d.y,
                j = c ? b(a.area / c) : 0,
                k;
            if (c == d.dx) {
                if (e || j > d.dy) j = d.dy;
                while (++f < g) k = a[f], k.x = h, k.y = i, k.dy = j, h += k.dx = Math.min(d.x + d.dx - h, j ? b(k.area / j) : 0);
                k.z = !0, k.dx += d.x + d.dx - h, d.y += j, d.dy -= j
            } else {
                if (e || j > d.dx) j = d.dx;
                while (++f < g) k = a[f], k.x = h, k.y = i, k.dx = j, i += k.dy = Math.min(d.y + d.dy - i, j ? b(k.area / j) : 0);
                k.z = !1, k.dy += d.y + d.dy - i, d.x += j, d.dx -= j
            }
        }

        function n(b) {
            var d = g || a(b),
                e = d[0];
            return e.x = 0, e.y = 0, e.dx = c[0], e.dy = c[1], g && a.revalue(e), i([e], e.dx * e.dy / e.value), (g ? k : j)(e), f && (g = d), d
        }
        var a = d3.layout.hierarchy(),
            b = Math.round,
            c = [1, 1],
            d = null,
            e = bc,
            f = !1,
            g, h = .5 * (1 + Math.sqrt(5));
        return n.size = function(a) {
            return arguments.length ? (c = a, n) : c
        }, n.padding = function(a) {
            function b(b) {
                var c = a.call(n, b, b.depth);
                return c == null ? bc(b) : bd(b, typeof c == "number" ? [c, c, c, c] : c)
            }

            function c(b) {
                return bd(b, a)
            }
            if (!arguments.length) return d;
            var f;
            return e = (d = a) == null ? bc : (f = typeof a) === "function" ? b : f === "number" ? (a = [a, a, a, a], c) : c, n
        }, n.round = function(a) {
            return arguments.length ? (b = a ? Math.round : Number, n) : b != Number
        }, n.sticky = function(a) {
            return arguments.length ? (f = a, g = null, n) : f
        }, n.ratio = function(a) {
            return arguments.length ? (h = a, n) : h
        }, z(n, a)
    }
})();

